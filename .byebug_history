exit
data["order_id"]
data
exit
let(:redis_mock) { instance_double(Redis) }
et(:redis_mock) { instance_double(Redis) }
Redis
redis_mock
exit
result = producer.publish(topic: topic, data: request_body)
request_body = "failed"
  end
c
expect(results.first[1]).to eq({ "payload" => request_body.to_json })
{ payload: request_body }
results.first[1]
c
options
consumer
group
group, consumer = fetch_group_and_consumer(options)
options
concurrency
topic
exit
@driver.consume(topic: topic, concurrency: concurrency, options: options)
options
concurrency
topic
exit
options[:group]
options
task_type
concurrency = fetch_concurrency_limit(task_type)
c
data
exit
Order.all
order.save
order.save\
order = Order.new(user_id: 1, order_date: Date.today, total_amount: 1)
Order.save
Order
c
redis_conn.lpush(PISTON_QUEUE, request_data.to_json)
request_data.to_json
exit
Order.count
Order
c
c\
data = JSON.parse(queue_data[1])
exit
Order.all
