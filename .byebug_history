c
expect(failed_at).to eq('2026-02-19 11:48:24 +0700')
expect(err_msg).to eq('Error dead letter')
expect(original_data).to eq({ order_id: order_id, total_payment: total_payment }.to_json)
expect(original_id).to eq('1707241234567-0')
c
expect(original_id).to eq('1707241234567-0')
c
Time.now.to_s
expect(original_id).to eq('1707241234567-0')
failed_at
err_msg
original_data
original_id
c
payload["original_id"]
payload
type == :dead_letter
type
c
type
c
type
c
original_data
original_id
message_id
c
failed_at
err_msg
original_data
original_id
c
producer.perform(topic: config.topic, data: { payload: {
            original_id: '1707241234567-0',
            original_data: request_body.to_json,
            error: 'Error dead letter',
            failed_at: Time.now.to_s
          } })
config.topic
c
expect(data["total_payment"]).to eq(total_payment)
expect(data["order_id"]).to eq(order_id)
c
expect(data["total_payment"]).to eq(total_payment)
expect(data["order_id"]).to eq(order_id)
c
redis.xadd(config.topic, { payload: {
            original_id: '1707241234567-0',
            original_data: request_body.to_json,
            error: 'Error dead letter',
            failed_at: Time.now.to_s
          }.to_json })
request_body.to_json
c
failed_at
err_msg
original_data
original_id
c
expect(data["total_payment"]).to eq(total_payment)
expect(data["order_id"]).to eq(order_id)
c
expect(data["total_payment"]).to eq(total_payment)
expect(data["order_id"]).to eq(order_id)
c
expect(data["total_payment"]).to eq(total_payment)
expect(data["order_id"]).to eq(order_id)
c
expect(data["total_payment"]).to eq(total_payment)
expect(data["order_id"]).to eq(order_id)
c
expect(data["total_payment"]).to eq(total_payment)
expect(data["order_id"]).to eq(order_id)
data
c
expect(data["total_payment"]).to eq(total_payment)
expect(data["order_id"]).to eq(order_id)
c
data
c
config.topic
c
config.topic
c
config.topic
c
config.topic
c
config.topic
c
config.topic
c
config.topic
c
config.topic
c
config.topic
c
config.topic
c
config.topic
c
config.topic
c
config.topic
c
config.topic
config.topic = "events_stream_retry"
config.topic
config
c
data
config.topic
c
@topic
c
topic
c
data
c
order_id
data
expect(data["order_id"]).to eq(order_id)
c
expect(data["total_payment"]).to eq(total_payment)
expect(data["order_id"]).to eq(order_id)
order_id
data["order_id"]
c
data["order_id"]
expect(data["order_id"]).to eq(order_id)
data
c
payload = JSON.parse(data["payload"])
id
data
c
data
c
result = messages["entries"] || []
messages
result
next_id, result, deleted_ids = messages
messages
next_id
result
c
messages
entries
c
messages
messages.nil? || messages.empty?
messages = @redis_pool.with do |conn|
                conn.xautoclaim(topic, group, consumer, 1000, '0-0', count: @config.redis_batch_size.to_i) # read stuck messages from redis stream as part of a consumer group.
              end
raw_response = @redis_pool.with do |conn|
  conn.xautoclaim(topic, group, consumer, 1000, '0-0', count: 10)
end
@config.redis_batch_size.to_i
c
messages
c
raw_response = @redis_pool.with do |conn|
  conn.xautoclaim(topic, group, consumer, 1000, '0-0', count: 10)
end
raw_response = @redis_pool.with do |conn|
  conn.xautoclaim(topic, group, consumer, 30000, '0-0', count: 10)
end
raw_response = @redis_pool.with do |conn|
  conn.xautoclaim(topic, group, consumer, 1000, '0-0', count: 10)
end
messages
c
data = redis.xrange(topic, '1771471559248-0')
redis.xpending(topic, group_name, "-", "+", 10)
c
@redis_pool.with do |conn| conn.xpending(topic, group, '-', '+', 10) end
@redis_pool.with do |conn| conn.xpending(topic, group, count: 10) end
@redis_pool.with do |conn| conn.xpending(topic, group, count: 20) end
@redis_pool.with do |conn| conn.xpending(topic, group) end
@redis_pool.with do |conn| conn.xpending(topic, group)
messages
consumer
group
topic
@config.redis_batch_size.to_i
messages
c
consumer_task.methods
consumer_task
c
redis.xreadgroup(group_name, consumer_name, topic, '>', count: 10)
redis.xreadgroup(group_name, consumer_name, topic, '>', 10)
c
@redis_pool.with do |conn| conn.xpending(topic, group) end
@redis_pool.with do |conn| conn.xpending(topic, group)
messages
messages.nil? || messages.empty?
consumer
group
topic
messages
exit
is_retry
log_message = "ðŸš€ reclaim main consumer #{consumer} started on topic [#{topic}], with fiber limit : #{fiber_limit}."
group, consumer = fetch_group_and_consumer(options: options)
c
options
enabled?(parameter_name: 'is_stop', value: options[:is_stop] || false)
enabled?(parameter_name: 'is_retry', value: options[:is_retry] || false)
fetch_fiber_limit(config: @config, task_type: task_type)
topic
